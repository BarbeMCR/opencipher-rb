# BarbeMCR's OpenCipher for Ruby
A Ruby encryption/decryption application and API designed to obfuscate files and text

**_DISCLAIMER: BarbeMCR's OpenCipher for Ruby is not meant for actual cryptographic purposes!_**

It is *not* built to protect sensitive information. Use it *only* for futile work.

While this application and its underlying API employ some security practices, you *shouldn't* trust either for securely encrypting things.

**_This is a Ruby reimplementation of BarbeMCR's OpenCipher (which is implemented in Python). Please note that files and strings encrypted with BarbeMCR's OpenCipher for Ruby are NOT compatible with BarbeMCR's OpenCipher (and viceversa) and will error on decryption._**

Here are the two main cosmetic differences with the original BarbeMCR's OpenCipher:
- The `*.key` file here holds the encrypted initial seed, while in the original it held the encrypted internal `random` PRNG state
- The SHA-512 checksum in the `*.auth` file here is a raw digest, while in the original it was an hexdigest

Again, any `*.lock`, `*.key` or `*.auth` file **(or string encryption output)** that was generated using BarbeMCR's OpenCipher for Ruby will *__NOT__* be decryptable in, nor otherwise compatible in (pretty much) any way with, BarbeMCR's OpenCipher *[the original Python implementation]*, *__and viceversa__*.

## BarbeMCR's OpenCipher for Ruby API

To use the BarbeMCR's OpenCipher module, just put `require_relative 'opencipher'` in your script.

Here is some brief documentation of all "public" functions of the `OpenCipher` module:

`OpenCipher.encrypt(file, secret, multiple:False, intervals:False)`

Encrypt `file`, which must be a valid path to a file, using `secret`.

The encryption algorithm works as follows:
- the PRNG provided by `Random` is initialized with a secure random seed (generated with `SecureRandom`)
- an encryption table is generated by randomly switching integers in range [0, 255], which represent all possible byte values
- if `multiple` is False or None, each byte in `file` is substituted using the encryption table and `file.lock` is written
- if `multiple` is True, a random `interval` in the range [1, 16] is chosen and each byte in an `interval`-sized chunk of `file` is substituted using the encryption table. Every `interval`, the encryption table is regenerated using the same method as above. If `intervals` is True, the `interval` is randomly set again
- the PRNG initial seed is passed to `OpenCipher.encrypt_key` for encryption to `file.key` based on `secret`
- the encryption products (`file.lock` and `file.key`) are authenticated to `file.auth` using `OpenCipher.authenticate`
- `file.lock`, `file.key` and `file.auth` are hashed using `opencipher.hash` and the result is appended to `file.auth`

`OpenCipher.encrypt_string(string, secret, multiple:False, intervals:False)`

Encrypt `string`, which must be a valid `String`. Returns an encrypted copy of `string`.

The encryption algorithm works as follows:
- the PRNG is initialized using `secret` as the seed
- an encryption table is generated by randomly switching integers in range [0, 255], which represent all possible byte values
- if `multiple` is False or None, each byte in `string` is substituted using the encryption table and the resulting bytes are converted to `0x`-prefixed hexadecimal numbers and joined with `:`
- if `multiple` is True, a random `interval` in the range [1, 16] is chosen and each byte in an `interval`-sized chunk of `string` is substituted using the encryption table. Every `interval`, the encryption table is regenerated using the same method as above. If `intervals` is True, the `interval` is randomly set again. In both cases, the resulting bytes are converted to `0x`-prefixed hexadecimal numbers and joined with `:`

`OpenCipher.encrypt_key(raw_key, key, secret)`

Encrypt `raw_key`, which must be an `Integer` representing the `Random` seed, to `key`, which must be a valid output path.

The encryption algorithm works as follows:
- the PNRG is initialized using `secret` as the seed
- an encryption table is generated by randomly switching integers in range [0, 255], which represent all possible byte values
- each byte of the `raw_key` is substituted using the encryption table
- the encrypted key is marshaled to `key`

`OpenCipher.authenticate(lock, key, auth, secret)`

Generate SHA-512 HMAC hexdigests for `lock` and `key` using `secret` and write them to `auth`, one after another. `lock` and `key` must be valid paths to the encrypted file and the encrypted key respectively, while `auth` must be a valid output path.

`OpenCipher.hash(lock, key, auth)`

Generate the SHA-512 hash for `lock`, `key` and `auth`, combined in a single `String` binary object. `lock`, `key` and `auth` must be valid paths to the encrypted file, the encrypted key and the digest store respectively. Returns the computed hash.

`OpenCipher.decrypt(file, key, auth, secret, multiple:False, intervals:False)`

Decrypt `file` using `key` and `secret`, after checking general validity with `auth`. `file`, `key` and `auth` must be valid paths to the encrypted file, the encrypted key and the digest and hash store respectively.

The decryption algorithm works as follows:
- `file`, `key` and `auth` are checked against corruption with `OpenCipher.check_hash`
- `file` and `key` are checked against tampering using `secret` with `OpenCipher.check_tampering`
- `key` is decrypted using `OpenCipher.decrypt_key`
- the PRNG initial seed is set using the decrypted key
- the file is decrypted using the same process as `OpenCipher.encrypt`, but the decrypted bytes are written using the table in reverse
- the decrypted file is written: if `file` was a `.*.lock` file, a corresponding `.*` file will be written

`OpenCipher.decrypt_string(enc_string, secret, multiple:False, intervals:False)`

Decrypt `enc_string`, which must be a valid `str`. Returns a decrypted copy of `enc_string`.

The decryption algorithm works as follows:
- the PRNG is initialized using `secret` as the seed
- the string is decrypted by first splitting it based on `:` and converting its parts back into integers, then applying the same process as `OpenCipher.encrypt_string`, but using the table in reverse

`OpenCipher.decrypt_key(key, secret)`

Decrypt `key`. Returns the decrypted `Integer` `Random` seed.

The decryption algorithm works as follows:
- the PNRG is initialized using `secret` as the seed
- `key` is decrypted using the same process as `OpenCipher.encrypt_key`, but using the table in reverse
- the decrypted key is unmarshaled

`OpenCipher.check_tampering(lock, key, auth, secret)`

Check if `lock` and `key` have been tampered with. Returns True if they haven't, False otherwise.

The first 128 chars of `auth` hold the SHA-512 HMAC hexdigest of `lock`, computed using `secret`. The next 128 chars of `auth` hold the SHA-512 HMAC hexdigest of `key`, computed using `secret`.

Those digests are compared with the corresponding digests generated in real time from `lock` and `key` using `secret`.

`OpenCipher.check_hash(lock, key, auth)`

Check if `lock`, `key` and `auth` are corrupted. Returns True if they aren't, False otherwise.

The last 128 chars of `auth` hold the SHA-512 hash of `lock`, `key` and the first 256 chars of `auth`, when all combined in a single `String` binary object.

This hash is compared with the corresponding hash generated in real time from `lock`, `key` and `auth`.

---

While there are several other "private" `OpenCipher._*_ui` methods, those are only used for the application interface. You can ignore those when using the API.

You **should** always wrap `OpenCipher.*` methods in a begin-rescue as follows:

```ruby
begin
  OpenCipher.<method>(*<arguments>)
  ...
rescue
  ...
end
```
